# 클로저(closure)

## 클로저란 ?
- 함수 + 그 함수가 만들어질 당시의 환경(변수들) 이 한 덩어리로 묶인 것

클로저 = 내부 함수(inner function)가, 자신이 만들어질 때의 외부 지역 변수들을 “기억”하고 있다가, 나중에 외부 함수가 끝난 뒤에도 계속 그 변수들을 사용할 수 있는 기능

## 클로저가 필요한 상황
case 1을 보면 지역변수는 함수가 끝나는 시점에 사라짐(lifespawn)
하지만 가끔, 어떤 값들을 기억하는 함수를 만들고 싶을때 사용.

case 2에선, add_10을 생성 시, 10이라는 지역변수를 저장해두고, 이후 L17과 같이 값을 더해서 사용할 수 있음.

## 클로저의 기본 형태
클로저가 되려면 세 조건이 필요함

1, 함수 안에 중첩 함수 (inner function) 가 있고

2, 그 중첩 함수 바깥 함수의 지역 변수를 사용해야 하고

3, 바깥 함수가 중첩 함수를 반환해야함.

## 클로저와 state
case 3을 보면, 호출 할 때 마다, 1씩 증가하는 카운트 함수를 작성하였음.

이러한 함수를 decorator로 두어, 이후 특정 endpoint로 요청이 많이 들어오는 작업에 대해서도 처리가 가능할듯.

## decorator

그래서 case 4를 보면, 걸린 시간을 체크해주는 decorator를 만듬

## 주의할 점
case 5 를 보면, 변수의 "값" 이 아닌, "변수 자체"를 캡쳐하기에 이러한 문제가 나올 수 있음 .

(i라는 변수를 세 번 바꾸면서 사용하였지만, 클로저는 동일한 i를 참조하고 있기에 loof가 끝난 시점에선 셋 다 2를 출력함.)

## Class 와의 차이
"상태를 지닌 기능"을 만들 때, 뭐로 해도 상관 없음.

다만, 클로저로 만들게 된다면 아래와 같은 특징이 있음. 
- 간단하고 가독성이 좋음.
- 여러 변수가 캡쳐되면 추상화가 흐려질 수 있음

-> 함수를 return하는 패턴 데코레이터, 콜백에 어울림.

클래스를 사용한다면 
- 상태와 메서드가 명시적임
- OOP 스타일과 잘 맞음

-> 복잡한 상태/여러 메서드가 필요할 때 적합.

## 최종 정리

클로저는 “함수 + 그 함수가 만들어질 때의 외부 변수들”을 함께 저장해서,
나중에도 그 환경을 유지한 채로 실행할 수 있게 해주는 기능.

키워드 정리:

lexical scope(정적 스코프) : 함수가 정의된 위치 기준으로 스코프 결정

중첩 함수(inner function) : 함수 안에서 정의된 함수

free variable(자유 변수) : 자기 스코프 안에 선언되지 않았지만, 바깥 스코프에서 가져다 쓰는 변수

closure : free variable + 그 변수를 사용하는 함수가 묶인 객체